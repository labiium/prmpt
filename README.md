# Curly

Curly is a command-line utility and Rust library designed to streamline interactions between code repositories and Large Language Models (LLMs). Specifically, it provides mechanisms to:

1. **Generate Prompts**: Convert your codebase into structured prompts for an LLM.
2. **Inject Code**: Reintegrate the code generated by the LLM into your original repository, updating files as necessary.

By combining automated prompt generation with reinsertion of LLM outputs, Curly promotes efficient workflows for tasks such as automated documentation, code reviews, refactoring, and project scaffolding.

---

## Table of Contents

- [Overview](#overview)
- [Directory Structure](#directory-structure)
- [Installation](#installation)
- [Usage](#usage)
  - [Generate](#generate)
  - [Inject](#inject)
  - [Custom Configurations](#custom-configurations)
- [Examples](#examples)
- [Configuration File](#configuration-file)
- [Prompt Format for LLMs](#prompt-format-for-llms)
- [Implementation Details](#implementation-details)
  - [Core Modules](#core-modules)
  - [Parsing Python Code](#parsing-python-code)
  - [Injecting LLM Output](#injecting-llm-output)
- [Contact](#contact)

---

## Overview

Curly is built to facilitate the round-trip of code to and from LLMs:

1. **Generating Prompts**: You can point Curly at a project directory, and it will traverse the code (respecting your ignore patterns and `.gitignore` if desired). For each file it finds, Curly can place file contents (or just docstrings/comments, if configured) into a user-specified output file. This output is typically used as a prompt for an LLM to read and modify your code or produce suggestions.

2. **Injecting Code**: After obtaining new or modified code blocks from the LLM, Curly can parse those code blocks and automatically inject them into the correct locations (overwriting or creating files as needed). This allows you to iterate on specific files (or an entire project) more efficiently.

**Key Features**:

- **Code-to-Prompt Conversion**: Scans files, adheres to ignore patterns, and provides a directory tree view followed by code blocks.
- **Selective Extraction**: Allows “docs-only” extraction, focusing on docstrings or comments (especially for Python).
- **Configurable**: Reads `curly.yaml` for custom configurations (e.g., project-wide ignore patterns, output file names, block delimiters).
- **Integration with Jupyter Notebooks**: Optionally includes code cells (and their outputs, if specified) from `.ipynb` files.
- **Parallel Processing**: Uses [Rayon](https://crates.io/crates/rayon) to speed up large repositories.

---

## Directory Structure

Below is a simplified representation of the core repository structure. Curly’s folder hierarchy demonstrates modular organization for parsing, injection, and configuration.

```
curly
├── README.md
├── Cargo.toml
├── src
│   ├── main.rs
│   ├── lib.rs
│   └── curly
│       ├── parse_python.rs
│       ├── run.rs
│       ├── inject_code.rs
│       ├── utils.rs
│       ├── config.rs
│       └── mod.rs
└── .gitignore
```

- **`src/main.rs`**: Entry point for the CLI.
- **`src/lib.rs`**: Exports key library functionality (e.g., `run`, `inject`, `Config`).
- **`src/curly/config.rs`**: Defines data structures and logic for reading/writing configurations from `curly.yaml`.
- **`src/curly/run.rs`**: Implements the prompt generation logic, walking directories, applying ignores, and aggregating file contents.
- **`src/curly/inject_code.rs`**: Handles parsing LLM-generated code blocks and inserting them into the appropriate file paths.
- **`src/curly/parse_python.rs`**: Extracts docstrings, class signatures, and function signatures from Python code via Tree-sitter.
- **`src/curly/utils.rs`**: Shared helper functions for managing ignore patterns, directory trees, and file operations.

---

## Installation

1. **Install Rust & Cargo**: Curly requires a working [Rust toolchain](https://www.rust-lang.org/tools/install).

2. **Clone and Build**:
   ```bash
   git clone https://github.com/yourusername/curly.git
   cd curly
   cargo build --release
   ```
   This produces the binary at `target/release/curly`, which you may optionally move to a directory in your `PATH`.

---

## Usage

Curly provides a command-line interface that can either invoke built-in commands or custom configurations defined in `curly.yaml`.

### Generate

**Purpose**: Create a prompt file by traversing a repository and collecting code snippets or docstrings.

- **Basic Example**:

  ```bash
  curly generate --path my_project --language rust --output output.txt
  ```

- **Key Flags**:
  - `--path`: Directory to scan (default: current directory).
  - `--language`: Language heuristics (e.g., `rust`, `python`) for ignoring typical build artifacts.
  - `--output`: Filename to store the generated prompt (default: `curly.out`).
  - `--ignore`: Can be repeated to match multiple ignore patterns (e.g., `--ignore "*.log"`).
  - `--docs-ignore`: Specifically ignore certain docstrings in a docs-only run.
  - `--delimiter`: Token used to demarcate code blocks in the generated file (default: ```` ``` ````).

### Inject

**Purpose**: Inject LLM-generated code back into your repository.

- **Basic Example**:

  ```bash
  curly inject --input output.txt --path my_project
  ```

- **Key Flags**:
  - `--input`: File containing the new or modified code blocks to insert (default: `curly.in`).
  - `--path`: Destination repository path (default: current directory).

### Custom Configurations

A `curly.yaml` file can define several named configurations (e.g., `base`, `docs_only`, etc.). You can run these directly by invoking `curly <config_name>`.

**Example `curly.yaml`**:
```yaml
base:
  path: my_project
  language: rust
  output: output.txt
  ignore:
    - "target"
    - "*.log"
  prompts:
    - "Add more tests for edge cases."
  use_gitignore: true

docs_only:
  path: docs
  language: python
  docs_comments_only: true
```

**Run**:
```bash
curly base
```
or
```bash
curly docs_only
```

---

## Examples

1. **Default Configuration**  
   Simply run `curly`, which will look for `base` in `curly.yaml`:
   ```bash
   curly
   ```

2. **Custom Configuration**  
   Run a named configuration `docs_only`:
   ```bash
   curly docs_only
   ```

3. **Inject New Code**  
   After editing or generating code with an LLM:
   ```bash
   curly inject --input llm_output.txt --path my_project
   ```

---

## Configuration File

Each named section in `curly.yaml` maps to a `Config` structure, allowing you to create multiple execution profiles. Key fields include:

- **`path`** *(string)*: Repository path to scan or modify.
- **`ignore`** *(list)*: Glob patterns to skip during scanning.
- **`output`** *(string)*: Where to write the generated prompt file.
- **`delimiter`** *(string)*: Code block delimiter for the generated prompt.
- **`language`** *(string)*: Language label (e.g., `rust`, `python`).
- **`prompts`** *(list)*: Additional textual prompts appended to the generated file.
- **`docs_comments_only`** *(bool)*: If `true`, only docstrings/comments are extracted (not full code).
- **`docs_ignore`** *(list)*: Patterns to skip even if `docs_comments_only` is active.
- **`use_gitignore`** *(bool)*: If `true`, includes `.gitignore` patterns.
- **`display_outputs`** *(bool)*: If `true`, extracts code-cell outputs in Jupyter notebooks.

---

## Prompt Format for LLMs

To seamlessly use Curly’s `inject` command, the LLM’s output must include proper file path designations and code blocks. A recommended format is:

1. A line with the relative file path. This can be enclosed in backticks or markdown headings,
   but a plain line works as well. For example:
   ```
   src/main.rs
   ```
2. Immediately followed by a fenced code block using the specified `delimiter` (default: ````` ``` `````):
   ```markdown
   ```rust
   fn main() {
       println!("Hello, world!");
   }
   ```
   ```

3. Repeat the above structure for each file that has additions or changes.

When `curly inject` runs, it reads these path and code-block segments, creating or overwriting files in the repository.

---

## Implementation Details

This section provides a brief academic overview of the principal modules and their responsibilities.

### Core Modules

- **`config`**: Defines the `Config` struct, representing user-defined or default settings for prompt generation.
- **`run`**: Orchestrates scanning, filtering, and code-block assembly.
- **`inject_code`**: Handles reading a text file for code blocks and placing them into the correct filesystem locations.
- **`utils`**: Implements shared logic for path manipulations, ignore patterns, and directory tree generation.

### Parsing Python Code

Curly leverages [Tree-sitter](https://tree-sitter.github.io/tree-sitter/) (via the `tree-sitter-python` crate) to perform more nuanced Python analysis, extracting docstrings and function/class signatures with abstract syntax tree (AST) traversal. This approach enables refined “docs-only” modes and provides structured context for docstring extraction.

### Injecting LLM Output

The injection process scans for the code block delimiter (by default, ````` ``` `````) and a file path listed directly before each block. The path line can be backticked or just a plain path. Upon encountering a matching pair, Curly writes the block’s content into that file, creating any needed parent directories. If multiple blocks reference the same file path, the tool overwrites the file in sequence.
